<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer-when-downgrade">

    <title>A step by step guide to make foreign functions less foreign</title>
    <meta name="description" content="">

    <link rel="stylesheet" href="https://example.com/main.css">

    

    
    
</head>
<body>
    <a class="skip-main" href="#main">Skip to content</a>
    <div class="container">
        <header> 
            <h1 class="site-header">
                <a href="https:&#x2F;&#x2F;example.com"></a>
            </h1>
            <nav>
                
                
                
            </nav>
        </header>
        <main id="main" tabindex="-1">
            

<article class="post">
    <header>
        <h1>A step by step guide to make foreign functions less foreign</h1>
    </header>
    <div class="content">
        <h1 id="a-step-by-step-guide-to-make-foreign-functions-less-foreign">A step by step guide to make foreign functions less foreign.</h1>
<p>An article about the basics of PureScript's foreign function interface (FFI), how to improve type safety by using TypeScript and JSDoc annotations and the <code>ts-bridge</code> tool.</p>
<h2 id="most-simple-example-for-ffi-import-a-value">Most simple example for FFI: Import a value</h2>
<p>Let's look at the most basic example of importing a foreign value from JavaScript into PureScript. On the PureScript side we use the <code>foreign import</code> syntax to declare a type for a value that will be provided by JavaScript. On the JavaScript side we export the actual implementation for this value.</p>
<p><em>Main.purs:</em></p>
<pre data-lang="hs" style="background-color:#2b303b;color:#c0c5ce;" class="language-hs "><code class="language-hs" data-lang="hs"><span style="color:#b48ead;">module </span><span>Main </span><span style="color:#b48ead;">where
</span><span>
</span><span>foreign </span><span style="color:#b48ead;">import</span><span> val1 :: Number
</span></code></pre>
<p><em>Main.js:</em></p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#b48ead;">export const </span><span style="color:#bf616a;">val1 </span><span>= </span><span style="color:#d08770;">13.0</span><span>;
</span></code></pre>
<p>This is by definition a potentially unsafe piece of code. The only thing that the PureScript compiler can check here is that a JavaScript file named <code>Main.js</code> exists and that it exports a value named <code>val1</code>. There's no way to check if the given type matches on both sides. Nothing prevents us to define <code>val1</code> as a string on the JavaScript side. E.g like:</p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#b48ead;">export const </span><span style="color:#bf616a;">val1 </span><span>= &quot;</span><span style="color:#a3be8c;">three</span><span>&quot;;
</span></code></pre>
<p>Chances are high that this will cause a runtime error at some other point in the program. How can we do better? The following post will demonstrate how this unsafety can be mitigated gradually.</p>
<h2 id="import-values-of-combined-types">Import values of combined types</h2>
<p>But before we start, let's first look at some slightly more complicated examples of foreign imports. By the way, this is called most of the time &quot;FFI&quot;, which stands for foreign function interface. But as you could see in the first example it's not only functions that can be imported from PureScript but also any kind of values.</p>
<p>We can also import/export combined types like Records and Arrays:</p>
<p><em>Main.purs:</em></p>
<pre data-lang="hs" style="background-color:#2b303b;color:#c0c5ce;" class="language-hs "><code class="language-hs" data-lang="hs"><span style="color:#b48ead;">module </span><span>Main </span><span style="color:#b48ead;">where
</span><span>
</span><span>foreign </span><span style="color:#b48ead;">import</span><span> val2 :: { name :: String, hobbies :: Array String }
</span></code></pre>
<p><em>Main.js:</em></p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#b48ead;">export const </span><span style="color:#bf616a;">val2 </span><span>= {
</span><span>  name: &quot;</span><span style="color:#a3be8c;">Alice</span><span>&quot;,
</span><span>  hobbies: [&quot;</span><span style="color:#a3be8c;">running</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">swimming</span><span>&quot;],
</span><span>};
</span></code></pre>
<h2 id="import-functions-curried-or-uncurried">Import functions, curried or uncurried</h2>
<p>We can import curried functions:</p>
<p><em>Main.purs:</em></p>
<pre data-lang="hs" style="background-color:#2b303b;color:#c0c5ce;" class="language-hs "><code class="language-hs" data-lang="hs"><span style="color:#b48ead;">module </span><span>Main </span><span style="color:#b48ead;">where
</span><span>
</span><span>foreign </span><span style="color:#b48ead;">import</span><span> val3 :: String -&gt; Boolean -&gt; Number
</span></code></pre>
<p><em>Main.js:</em></p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#b48ead;">export const </span><span style="color:#8fa1b3;">val3 </span><span>= (</span><span style="color:#bf616a;">str</span><span>) </span><span style="color:#b48ead;">=&gt; </span><span>(</span><span style="color:#bf616a;">isTrue</span><span>) </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>  </span><span style="color:#65737e;">// Some random pure code:
</span><span>  </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">isTrue </span><span>? </span><span style="color:#bf616a;">str</span><span>.length : </span><span style="color:#d08770;">0</span><span>;
</span><span>};
</span></code></pre>
<p>We can use some helpers to export uncurried functions to make the JS code more idiomatic:</p>
<p><em>Main.purs:</em></p>
<pre data-lang="hs" style="background-color:#2b303b;color:#c0c5ce;" class="language-hs "><code class="language-hs" data-lang="hs"><span style="color:#b48ead;">module </span><span>Main </span><span style="color:#b48ead;">where
</span><span>
</span><span style="color:#b48ead;">import </span><span>Data.Function.Uncurried (</span><span style="color:#b48ead;">Fn2</span><span>)
</span><span>
</span><span>foreign </span><span style="color:#b48ead;">import</span><span> val4 :: Fn2 String Boolean Number
</span></code></pre>
<p><em>Main.js:</em></p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#b48ead;">export const </span><span style="color:#8fa1b3;">val4 </span><span>= (</span><span style="color:#bf616a;">str</span><span>, </span><span style="color:#bf616a;">isTrue</span><span>) </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>  </span><span style="color:#65737e;">// Some random pure code:
</span><span>  </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">isTrue </span><span>? </span><span style="color:#bf616a;">str</span><span>.length : </span><span style="color:#d08770;">0</span><span>;
</span><span>};
</span></code></pre>
<h2 id="import-effectful-functions">Import effectful functions</h2>
<p>And we can also declare some functions to be effectful. And, as you can image, all of the above can be combined and mixed:</p>
<p><em>Main.purs:</em></p>
<pre data-lang="hs" style="background-color:#2b303b;color:#c0c5ce;" class="language-hs "><code class="language-hs" data-lang="hs"><span style="color:#b48ead;">module </span><span>Main </span><span style="color:#b48ead;">where
</span><span>
</span><span style="color:#b48ead;">import </span><span>Effect.Uncurried (</span><span style="color:#b48ead;">EffectFn2</span><span>, </span><span style="color:#b48ead;">EffectFn3</span><span>)
</span><span>
</span><span>foreign </span><span style="color:#b48ead;">import</span><span> val5
</span><span>  :: </span><span style="color:#d08770;">EffectFn3
</span><span>       { onTick :: </span><span style="color:#d08770;">EffectFn2 String Number Boolean</span><span> }
</span><span>       </span><span style="color:#d08770;">Boolean
</span><span>       </span><span style="color:#d08770;">String
</span><span>       { cancel :: </span><span style="color:#d08770;">Effect Unit</span><span> }
</span></code></pre>
<p><em>Main.js:</em></p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#b48ead;">export const </span><span style="color:#8fa1b3;">val5 </span><span>= (</span><span style="color:#bf616a;">opts</span><span>, </span><span style="color:#bf616a;">bool</span><span>, </span><span style="color:#bf616a;">str</span><span>) </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>  </span><span style="color:#65737e;">// Some random side effecting code:
</span><span>  
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">intervalId </span><span>= </span><span style="color:#96b5b4;">setInterval</span><span>(() </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>    </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">result </span><span>= </span><span style="color:#bf616a;">opts</span><span>.</span><span style="color:#8fa1b3;">onTick</span><span>(&quot;</span><span style="color:#a3be8c;">abc</span><span>&quot;, </span><span style="color:#d08770;">13</span><span>);
</span><span>    </span><span style="color:#ebcb8b;">console</span><span>.</span><span style="color:#96b5b4;">log</span><span>(</span><span style="color:#bf616a;">result </span><span>? &quot;</span><span style="color:#a3be8c;">Tick!</span><span>&quot; : &quot;</span><span style="color:#a3be8c;">Tack!</span><span>&quot;);
</span><span>  }, </span><span style="color:#d08770;">1000.0</span><span>);
</span><span>
</span><span>  </span><span style="color:#b48ead;">return </span><span>{
</span><span>    </span><span style="color:#8fa1b3;">cancel</span><span>: () </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>      </span><span style="color:#96b5b4;">clearInterval</span><span>(</span><span style="color:#bf616a;">intervalId</span><span>);
</span><span>      </span><span style="color:#ebcb8b;">console</span><span>.</span><span style="color:#96b5b4;">log</span><span>(&quot;</span><span style="color:#a3be8c;">canceled!</span><span>&quot;);
</span><span>    },
</span><span>  };
</span><span>};
</span></code></pre>
<p>Values of type <code>Fn2</code>, <code>Fn3</code>, or <code>EffectFn4</code> can be easily converted into idiomatic PureScript functions using helpers like <code>runFn2</code>, <code>runFn3</code>, or <code>runEffectFn4</code>. And they can be created from PureScript functions with <code>mkFn2</code>, <code>mkFn3</code>, or <code>mkEffectFn4</code>.</p>
<p>Now we have defined 5 sample values that we want to import from JavaScript to PureScript. Some are simple, others more complex. But what they share is that all of them have an <em>implicit</em> contract that the dynamic JavaScript code matches the type signature on the PureScript side.
It's <em>implicit</em> because in order to check this we need to read the whole JavaScript code to make sure the function parameters are used in the &quot;right way&quot; at every place. Especially the last example (<code>val5</code>) should demonstrate how easy it is to make some mistakes in the body of the function.</p>
<h2 id="which-types-can-be-used-in-ffi">Which types can be used in FFI?</h2>
<p>Generally all values can be used in FFI of which the runtime representation is known and guaranteed to be equal for every compiler backend. This is the case for primitives like <code>String</code>, <code>Boolean</code>, <code>Number</code>, <code>Array</code>, <code>Record</code>, <code>Function</code> as well as some other types that claim to give you this guarantee. E.g. <code>Fn1..n</code>, <code>EffectFn1..n</code> or types like <code>Nullable</code>.</p>
<p>It's important to keep in mind that PureScript data types, like <code>Maybe</code>, <code>Either</code>, <code>Tuple</code> or some others that you define yourself, don't have this guarantee. So they cannot be used in FFI. Concretely their representation differs in the standard JavaScript compiler backend and the <a href="https://github.com/aristanetworks/purescript-backend-optimizer">optimized one</a>.</p>
<h2 id="make-the-contract-explicit-with-typescript-and-jsdoc">Make the contract explicit with TypeScript and JSDoc</h2>
<p>Now I'd like to demonstrate a very simple way to make the above examples safer by making the <em>implicit</em> contracts <em>explicit</em> by using <a href="https://jsdoc.app/">JSDoc</a>. The PureScript code stays at it is but on the JavaScript side we add some JSDoc annotations to the exported values:</p>
<p><em>Main.js</em></p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#65737e;">// @ts-check
</span><span>
</span><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * </span><span style="color:#b48ead;">@type </span><span style="color:#65737e;">{number}
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">export const </span><span style="color:#bf616a;">val1 </span><span>= </span><span style="color:#d08770;">3</span><span>;
</span><span>
</span><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * </span><span style="color:#b48ead;">@type </span><span style="color:#65737e;">{{name : string, hobbies: Array&lt;string&gt;}}
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">export const </span><span style="color:#bf616a;">val2 </span><span>= {
</span><span>  name: &quot;</span><span style="color:#a3be8c;">Alice</span><span>&quot;,
</span><span>  hobbies: [&quot;</span><span style="color:#a3be8c;">running</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">swimming</span><span>&quot;],
</span><span>};
</span><span>
</span><span style="color:#65737e;">/** </span><span style="color:#b48ead;">@type </span><span style="color:#65737e;">{(s: string) =&gt; (b: boolean) =&gt; number}  */
</span><span style="color:#b48ead;">export const </span><span style="color:#8fa1b3;">val3 </span><span>= (</span><span style="color:#bf616a;">str</span><span>) </span><span style="color:#b48ead;">=&gt; </span><span>(</span><span style="color:#bf616a;">isTrue</span><span>) </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>  </span><span style="color:#65737e;">// Some random pure code:
</span><span>  </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">isTrue </span><span>? </span><span style="color:#bf616a;">str</span><span>.length : </span><span style="color:#d08770;">0</span><span>;
</span><span>};
</span><span>
</span><span style="color:#65737e;">/** </span><span style="color:#b48ead;">@type </span><span style="color:#65737e;">{(s: string, b: boolean) =&gt; number}  */
</span><span style="color:#b48ead;">export const </span><span style="color:#8fa1b3;">val4 </span><span>= (</span><span style="color:#bf616a;">str</span><span>, </span><span style="color:#bf616a;">isTrue</span><span>) </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>  </span><span style="color:#65737e;">// Some random pure code:
</span><span>  </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">isTrue </span><span>? </span><span style="color:#bf616a;">str</span><span>.length : </span><span style="color:#d08770;">0</span><span>;
</span><span>};
</span><span>
</span><span style="color:#65737e;">/** </span><span style="color:#b48ead;">@type </span><span style="color:#65737e;">{(opts: {onTick : (str : string, num: number, bool: boolean) =&gt; boolean}, bool: number, str: string) =&gt; {cancel : () =&gt; void}}  */
</span><span style="color:#b48ead;">export const </span><span style="color:#8fa1b3;">val5 </span><span>= (</span><span style="color:#bf616a;">opts</span><span>, </span><span style="color:#bf616a;">bool</span><span>, </span><span style="color:#bf616a;">str</span><span>) </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>  </span><span style="color:#65737e;">// Some random side effecting code:
</span><span>  
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">intervalId </span><span>= </span><span style="color:#96b5b4;">setInterval</span><span>(() </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>    </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">result </span><span>= </span><span style="color:#bf616a;">opts</span><span>.</span><span style="color:#8fa1b3;">onTick</span><span>(&quot;</span><span style="color:#a3be8c;">abc</span><span>&quot;, </span><span style="color:#d08770;">13</span><span>);
</span><span>    </span><span style="color:#ebcb8b;">console</span><span>.</span><span style="color:#96b5b4;">log</span><span>(</span><span style="color:#bf616a;">result </span><span>? &quot;</span><span style="color:#a3be8c;">Tick!</span><span>&quot; : &quot;</span><span style="color:#a3be8c;">Tack!</span><span>&quot;);
</span><span>  }, </span><span style="color:#d08770;">1000.0</span><span>);
</span><span>
</span><span>  </span><span style="color:#b48ead;">return </span><span>{
</span><span>    </span><span style="color:#8fa1b3;">cancel</span><span>: () </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>      </span><span style="color:#96b5b4;">clearInterval</span><span>(</span><span style="color:#bf616a;">intervalId</span><span>);
</span><span>      </span><span style="color:#ebcb8b;">console</span><span>.</span><span style="color:#96b5b4;">log</span><span>(&quot;</span><span style="color:#a3be8c;">canceled!</span><span>&quot;);
</span><span>    },
</span><span>  };
</span><span>};
</span></code></pre>
<p>This is still a JavaScript file, but as you can see in the first line we added a <code>@ts-check</code> directive. This enables the TypeScript compiler to check the JSDoc annotations. More information about this can be <a href="https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html">found here</a>. So if you run <code>tsc</code> (the CLI of the TypeScript Compiler) inside the repository you will get errors if the implementations of the values don't match up with the provided type annotations. Here's an example:</p>
<pre data-lang="sh" style="background-color:#2b303b;color:#c0c5ce;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#bf616a;">npm</span><span> install typescript
</span><span>
</span><span style="color:#bf616a;">tsc --allowJs --noEmit</span><span> src/Main.js
</span></code></pre>
<p>If you change the line <code>opts.onTick(&quot;Hello&quot;, 13)</code> to e.g. <code>opts.onTick(&quot;Hello&quot;, &quot;13&quot;)</code>, you'll get a type error from TypeScript.</p>
<p>You can also configure a <code>tsconfig.json</code> file to make this work for the whole folder.</p>
<p>At this point the manual reviewing of the code became much easier and less error prone. We only need to check if the provided PureScript type signatures match up with the JSDoc annotations. We don't have to read every single line of the JavaScript code anymore to be confident that the types are correct.</p>
<h2 id="statically-check-the-contract-by-using-ts-bridge">Statically check the contract by using <code>ts-bridge</code></h2>
<p>For some users this might be enough. But if you want to go one step further and statically check the contract between PureScript and JavaScript you can use the <code>ts-bridge</code> tool. This library can generate TypeScript types from PureScript types. Let's see how it can be set up for our examples. </p>
<p>TODO: note about the <code>ts-bridge</code> version</p>
<pre data-lang="sh" style="background-color:#2b303b;color:#c0c5ce;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#bf616a;">spago</span><span> install ts-bridge
</span></code></pre>
<p>Now we need to change the PureScript file a bit. The FFI definitions remain the same but we'll add some imports and the following section to the bottom:</p>
<pre data-lang="hs" style="background-color:#2b303b;color:#c0c5ce;" class="language-hs "><code class="language-hs" data-lang="hs"><span style="color:#b48ead;">import </span><span>DTS </span><span style="color:#b48ead;">as </span><span>DTS
</span><span style="color:#b48ead;">import </span><span>TsBridge </span><span style="color:#b48ead;">as </span><span>TSB
</span><span style="color:#b48ead;">import </span><span>TsBridge.Class (</span><span style="color:#b48ead;">Tok</span><span style="color:#8fa1b3;">(..)</span><span>)
</span><span>
</span><span style="color:#65737e;">-- FFI definitions from above ...
</span><span>
</span><span style="color:#8fa1b3;">tsModules </span><span style="color:#b48ead;">:: Either TSB</span><span>.</span><span style="color:#b48ead;">AppError</span><span> (</span><span style="color:#b48ead;">Array DTS</span><span>.</span><span style="color:#b48ead;">TsModuleFile</span><span>)
</span><span>tsModules =
</span><span>  </span><span style="color:#d08770;">TSB</span><span>.tsModuleFile &quot;</span><span style="color:#a3be8c;">Main</span><span>&quot;
</span><span>    [ </span><span style="color:#d08770;">TSB</span><span>.tsTypeAliasesFromValues </span><span style="color:#d08770;">TSB</span><span>.</span><span style="color:#d08770;">Tok
</span><span>        { val1
</span><span>        , val2
</span><span>        , val3
</span><span>        , val4
</span><span>        , val5
</span><span>        }
</span><span>    ]
</span></code></pre>
<p>Moreover we add a separate module to the codebase which will be used to generate the TypeScript types:</p>
<pre data-lang="hs" style="background-color:#2b303b;color:#c0c5ce;" class="language-hs "><code class="language-hs" data-lang="hs"><span style="color:#b48ead;">module </span><span>Bridge </span><span style="color:#b48ead;">where
</span><span>
</span><span style="color:#b48ead;">import </span><span>Prelude
</span><span>
</span><span style="color:#b48ead;">import </span><span>DTS </span><span style="color:#b48ead;">as </span><span>DTS
</span><span style="color:#b48ead;">import </span><span>Data.Either (</span><span style="color:#b48ead;">Either</span><span>)
</span><span style="color:#b48ead;">import </span><span>Effect (</span><span style="color:#b48ead;">Effect</span><span>)
</span><span style="color:#b48ead;">import </span><span>Main </span><span style="color:#b48ead;">as </span><span>Main
</span><span style="color:#b48ead;">import </span><span>TsBridge </span><span style="color:#b48ead;">as </span><span>TSB
</span><span style="color:#b48ead;">import </span><span>TsBridge </span><span style="color:#b48ead;">as </span><span>TsBridge
</span><span>
</span><span style="color:#8fa1b3;">myTsProgram </span><span style="color:#b48ead;">:: Either TSB</span><span>.</span><span style="color:#b48ead;">AppError DTS</span><span>.</span><span style="color:#b48ead;">TsProgram
</span><span>myTsProgram =
</span><span>  </span><span style="color:#d08770;">TSB</span><span>.tsProgram
</span><span>    [ </span><span style="color:#d08770;">Main</span><span>.tsModules
</span><span>    ]
</span><span>
</span><span style="color:#8fa1b3;">main </span><span style="color:#b48ead;">:: Effect Unit
</span><span>main = </span><span style="color:#d08770;">TsBridge</span><span>.mkTypeGenCli myTsProgram
</span></code></pre>
<p>That's it. Now we can run <code>spago run --main Bridge</code> and we'll get the following output:</p>
<pre data-lang="sh" style="background-color:#2b303b;color:#c0c5ce;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#bf616a;">output/Main/index.d.ts
</span></code></pre>
<p>This means that TypeScript types were generated for the <code>Main</code> module and written to the <code>output/Main/index.d.ts</code> file. Let's have a look at the content of this file:</p>
<pre data-lang="ts" style="background-color:#2b303b;color:#c0c5ce;" class="language-ts "><code class="language-ts" data-lang="ts"><span style="color:#b48ead;">export const </span><span style="color:#bf616a;">val1 </span><span>: number
</span><span>
</span><span style="color:#b48ead;">export const </span><span style="color:#bf616a;">val2 </span><span>: { </span><span style="color:#b48ead;">readonly </span><span>&#39;</span><span style="color:#a3be8c;">hobbies</span><span>&#39;: Array&lt;string&gt;; </span><span style="color:#b48ead;">readonly </span><span>&#39;</span><span style="color:#a3be8c;">name</span><span>&#39;: string; }
</span><span>
</span><span style="color:#b48ead;">export const </span><span style="color:#bf616a;">val3 </span><span>: (</span><span style="color:#bf616a;">_</span><span>: string) </span><span style="color:#b48ead;">=&gt; </span><span>(</span><span style="color:#bf616a;">_</span><span>: boolean) </span><span style="color:#b48ead;">=&gt; </span><span>number⏎      
</span></code></pre>
<p>Those are exactly the signatures that we manually added in the JS file in the form of JSDoc annotations. But now they are generated automatically from the PureScript code.</p>
<p>As a last step we need a way to replace the handwritten type definitions with the generated ones. Luckily TypeScript has extended the JSDoc syntax a bit to support a couple of TypeScript specific features, especially we can use the import statement to replace the concrete types:</p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * </span><span style="color:#b48ead;">@type </span><span style="color:#65737e;">{import(&quot;../output/Main&quot;).val1}
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">export const </span><span style="color:#bf616a;">val1 </span><span>= </span><span style="color:#d08770;">3</span><span>;
</span><span>
</span><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * </span><span style="color:#b48ead;">@type </span><span style="color:#65737e;">{import(&quot;../output/Main&quot;).val2}
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">export const </span><span style="color:#bf616a;">val2 </span><span>= {
</span><span>  name: &quot;</span><span style="color:#a3be8c;">ALice</span><span>&quot;,
</span><span>  hobbies: [&quot;</span><span style="color:#a3be8c;">running</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">swimming</span><span>&quot;],
</span><span>};
</span><span>
</span><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * </span><span style="color:#b48ead;">@type </span><span style="color:#65737e;">{import(&quot;../output/Main&quot;).val3}
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">export const </span><span style="color:#8fa1b3;">val3 </span><span>= (</span><span style="color:#bf616a;">s</span><span>) </span><span style="color:#b48ead;">=&gt; </span><span>(</span><span style="color:#bf616a;">b</span><span>) </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>  </span><span style="color:#65737e;">// Some random pure code:
</span><span>  </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">b </span><span>? </span><span style="color:#bf616a;">s</span><span>.length : </span><span style="color:#d08770;">0</span><span>;
</span><span>};
</span><span>
</span><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * </span><span style="color:#b48ead;">@type </span><span style="color:#65737e;">{import(&quot;../output/Main&quot;).val4}
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">export const </span><span style="color:#8fa1b3;">val4 </span><span>= (</span><span style="color:#bf616a;">s</span><span>, </span><span style="color:#bf616a;">b</span><span>) </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>  </span><span style="color:#65737e;">// Some random pure code:
</span><span>  </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">b </span><span>? </span><span style="color:#bf616a;">s</span><span>.length : </span><span style="color:#d08770;">0</span><span>;
</span><span>};
</span><span>
</span><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * </span><span style="color:#b48ead;">@type </span><span style="color:#65737e;">{import(&quot;../output/Main&quot;).val5}
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">export const </span><span style="color:#8fa1b3;">val5 </span><span>= (</span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#bf616a;">b</span><span>, </span><span style="color:#bf616a;">c</span><span>) </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>  </span><span style="color:#ebcb8b;">console</span><span>.</span><span style="color:#96b5b4;">log</span><span>(&quot;</span><span style="color:#a3be8c;">Side effect:</span><span>&quot;);
</span><span>  </span><span style="color:#bf616a;">a</span><span>.</span><span style="color:#8fa1b3;">cb</span><span>(&quot;</span><span style="color:#a3be8c;">Hello</span><span>&quot;, </span><span style="color:#d08770;">42</span><span>, </span><span style="color:#d08770;">true</span><span>);
</span><span>
</span><span>  </span><span style="color:#b48ead;">return </span><span>{
</span><span>    </span><span style="color:#8fa1b3;">cancel</span><span>: () </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>      </span><span style="color:#ebcb8b;">console</span><span>.</span><span style="color:#96b5b4;">log</span><span>(&quot;</span><span style="color:#a3be8c;">canceled!</span><span>&quot;);
</span><span>    },
</span><span>  };
</span><span>};
</span></code></pre>
<p>You can check that this works by running the full build pipeline which is now:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>spago run --main Bridge
</span><span>tsc --allowJs --noEmit src/Main.js
</span><span>spago build
</span></code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>PureScript's foreign function interface is a very powerful feature. However, it comes with the cost of being quite unsafe: This is because it needs to close the gap between the PureScript type system and the dynamically typed JavaScript.
However, nowadays JavaScript is not that unsafe anymore. Many libraries are written in TypeScript or at least additional type declarations are being provided.
That's a value that we can use to make the FFI safer. To be fair, it cannot be as safe as code that has been written natively in PureScript. There are still many pitfalls to be aware of once the interfaces get more complex. But still it's a big improvement over the &quot;implicit&quot; contracts that we had before.</p>
<p>PureScript is still a language with a relatively small community and therefore a the ecosystem is not as large as the one of JavaScript. By bridging the gap between PureScript and TypeScript we can leverage the power of the TypeScript ecosystem and make it available to PureScript users. This may also encourage newcomers to use PureScript. For instance I was amazed to see that the interoperability with TypeScript was one of the first features promoted by the language ReScript: On their <a href="https://rescript-lang.org/">homepage</a> they write: &quot;Use any library from JavaScript, export ReScript libraries to JavaScript, automatically generate TypeScript types&quot;.</p>
<p>I wrote <a href="https://github.com/thought2/purescript-ts-bridge">ts-bridge</a> about a year ago with the goal to provide a similar experience for PureScript users as the one claimed by e.g. ReScript.
And I think I focused a bit too much on documenting the opposite use case: Which is calling PureScript code from TypeScript.
But I think calling JS/TS from PureScript as FFI is more common.
So this is the missing tutorial for this use case. Hope you enjoyed it and can take away something useful from it: Be it a better understanding of how FFI works, how to use JSDoc annotations or how to use <code>ts-bridge</code> to make your FFI safer.</p>
<h2 id="the-future-of-ts-bridge">The future of <code>ts-bridge</code></h2>
<p>The following sections contains some more details about how <code>ts-bridge</code> works and how it could be improved in the future. It's not necessary to understand this in order to use <code>ts-bridge</code> but it might be interesting for some users.
Unfortunately it is not yet fully automatic. Ideally it wouldn't need any boilerplate code inside your actual codebase to set it up. Ideally it would come as an external tool that you can run on your codebase and it would generate the TypeScript types automatically.
Currently it is based on type class resolution, a bit like type class based JSON encoding works.
In order to make it really standalone obtaining the resolved CST would be necessary. Getting the actual CST <a href="https://github.com/natefaubion/purescript-language-cst-parser">is easy</a> but getting the resolved one is more difficult. After a discussion on the PureScript Discord channel it turned out that the only way to do so is to communicate with the language server. Just like IDE plugins do: If you hover over a symbol in your editor the IDE plugin will show you the unresolved type of that symbol (e.g. <code>User</code>) as well as the resolved one (e.g. <code>{name :: String, id :: Int }</code>). Maybe in the future a CLI like this will be possible, it comes with a couple of challenges though: E.g. how to configure/register custom types with specific runtime representations. In the current approach this is simpler by just writing type class instances for the type.</p>

    </div>

    
    <div class="article-info">
        
        <div class="article-taxonomies">
            
            
        </div>
    </div>

</article>


        </main>
        <footer>
            <p>
                ©  2023<br>
                Powered by <a target="_blank" href="https://getzola.org/">Zola</a>, Theme <a target="_blank" href="https://github.com/zbrox/anpu-zola-theme">Anpu</a>.
            </p>
            <p>
                
                
            </p>
        </footer>
    </div>

    <div class="dark-mode-buttons">
  <button class="dark-mode-button" id="dark-mode-on">
    <img
      src="https://example.com/dark_mode.svg"
      width="24"
      height="24"
      alt="Dark mode"
      aria-label="dark mode toggle"
      title="Dark mode"
    />
  </button>
  <button class="dark-mode-button" id="dark-mode-off">
    <img
      src="https://example.com/light_mode.svg "
      width="24"
      height="24"
      alt="Light mode"
      aria-label="light mode toggle"
      title="Light mode"
      style="filter: invert(1);"
    />
  </button>
</div>
<script>
  const cls = document.body.classList;
  const getSessionTheme = sessionStorage.getItem("theme");
  if (getSessionTheme === "dark") {
    cls.toggle("dark-mode", true);
  } else if (getSessionTheme === "light") {
    cls.toggle("dark-mode", false);
  } else if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
    cls.toggle("dark-mode", true);
  }
  document
    .getElementById("dark-mode-on")
    .addEventListener("click", function (e) {
      cls.toggle("dark-mode", true);
      sessionStorage.setItem("theme", "dark");
    });
  document
    .getElementById("dark-mode-off")
    .addEventListener("click", function (e) {
      cls.toggle("dark-mode", false);
      sessionStorage.setItem("theme", "light");
    });
</script>
<noscript>
  <style>
    .dark-mode-buttons {
      display: none;
    }
  </style>
</noscript>

    
</body>
</html>
